Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Кафедра програмної інженерії

Звіт з лабораторної роботи № 4
з дисципліни «Архітектура програмного забезпечення»
на тему «Розробка програмної архітектури,
створення та відлагодження програмного коду
вебклієнта програмної системи»

Виконав:
      студент групи ПЗПІ-22-7
   					       Сахань Дмитро Олександрович
                  15 червня 2025р.			                                              
   Перевірив:
     ст. викладач кафедри ПІ
      Сокорчук Ігор Петрович

	

	



Харків, 2025

4.1 Мета роботи


На лабораторній роботі №4 потрібно розробити клієнтську / фронтенд-частину програмної системи.


4.2 Історія змін

Таблиця 1 — Історія змін та виправлень роботи

 № 	Дата	 Версія звіту 	Опис змін та виправлень
 1	 07.05.2025 	 0.1	 Створено лабораторну №4















4.3 Хід роботи
Ця частина програмної системи повинна забезпечувати підтримку роботи користувачів у веб-середовищі, а також функціональність адміністрування. Користувацький інтерфейс передбачає підтримку мультимовності та адаптивності, з урахуванням локалізації (українська та англійська мови), різних форматів дати та одиниць вимірювання (метричні й англо-американські).
Інтерфейс адміністратора повинен забезпечувати функції управління користувачами, перегляду зареєстрованих облікових даних, а також збереження або очищення локальних даних. Підтримується захищений доступ через пароль. Платформа також реалізує взаємодію з серверною частиною через REST API для аналізу сенсорних показників та надання рекомендацій.

4.4 Опис виконаної роботи
4.4.1 Технологічний стек та архітектура (доповнено)
Фронтенд вебінтерфейсу системи моніторингу ґрунту розроблено з використанням HTML, CSS та JavaScript. Адаптивний інтерфейс реалізований у вигляді вкладок, що спрощує взаємодію з ключовими модулями (ґрунт, метео, сезони тощо).
На серверній стороні використовується Python у поєднанні з мікрофреймворком Flask для створення REST API. Для збереження та обробки даних впроваджена реляційна база даних — наприклад, Microsoft SQL Server або PostgreSQL.
Для взаємодії з базою даних використовуються такі бібліотеки:
•	SQLAlchemy — ORM-бібліотека, що дозволяє працювати з таблицями як з об’єктами Python, автоматизуючи запити та структуру таблиць.
•	Flask-SQLAlchemy — інтеграція SQLAlchemy з Flask, яка спрощує ініціалізацію, конфігурацію та використання бази в застосунку.
•	Marshmallow — для серіалізації/десеріалізації об'єктів при обміні JSON-даними між клієнтом і сервером.
•	PyODBC або psycopg2 — драйвери для підключення до відповідних СУБД (SQL Server або PostgreSQL).
Ці компоненти забезпечують збереження сенсорних даних, користувацької інформації, порогових значень, історії змін і резервного копіювання налаштувань системи.
4.4.2 Основні модулі та сторінки
Система включає декілька ключових сторінок:
•	Аналіз ґрунту — введення pH, вологи, макроелементів та культури;
•	Метео — введення температури, вологості, швидкості вітру та приміток;
•	Сезони — фіксація сезону висадки для певної культури;
•	Рекомендації — виведення загальних порад щодо обробки ґрунту;
•	Реєстрація — створення облікового запису, який зберігається в localStorage;
•	Адміністрування — закрита паролем панель з можливістю перегляду зареєстрованих даних, очищення сховища тощо.

4.4.3 Інтеграція з API
Система взаємодіє з серверною частиною через REST API для надсилання сенсорних показників та отримання аналітики. Наприклад, якщо рівень вологості перевищує норму для заданої культури (наприклад, 60% проти 50% норми для кукурудзи), користувач отримає рекомендацію щодо зменшення поливу. Вся логіка інтеграції побудована на fetch або axios (у разі розширення), що дозволяє реалізувати асинхронні запити до серверної частини з мінімальними затримками.

4.4.4 Особливості реалізації
Інтерфейс підтримує адаптивну верстку для мобільних пристроїв, що особливо важливо для використання в польових умовах. Локалізація реалізована через JSON-словники, що легко розширюються. Кнопки, поля та панелі мають мінімалістичний дизайн із кольоровим маркуванням для кращої читаємості. Вся логіка поділена на функції, що спрощує обслуговування та можливість подальшого масштабування.



4.5 Висновки
У результаті виконаної роботи було розроблено повноцінний вебінтерфейс для системи моніторингу та аналізу ґрунту. Система забезпечує зручне введення та перегляд даних, підтримує багатомовність, а також містить механізми захисту адміністративної панелі.
Розробка базується на принципах адаптивності, модульності та зручності користування. Реалізовано початкову інтеграцію з серверною частиною для аналізу показників та генерації рекомендацій, що відкриває можливості для розширення системи на повноцінний IoT-рівень. Система є гнучкою до масштабування, зручна у використанні та готова до подальшого розвитку.
URL на код на GitHub: https://github.com/NureSakhanDmytro/apz-pzpi-22-7-sakhan-dmytro/edit/main/Lab4/pzpi-22-7-sakhan-dmytro-lab4.txt


















ДОДАТОК А
Посилання на відеозапис та хронологічний опис доповіді

Відеозапис доповіді на https://youtu.be/eYBU4vqbvhI

00:00 - Привітання, вступ 
00:36 - Постановка задачі лабораторної 
01:20 - Опис виконаної роботи 
03:00 - Основні модулі 
03:25 - Інтеграція з API 
03:49 - Особливості реалізації 
04:17 - Висновки 
05:03 - Показ роботи програми 
10:34 - «Дякую за увагу!»













ДОДАТОК Б
UML-діаграми
 
Рисунок Б.1 — UML-діаграма прецедентів (Use Case Diagram) фронтенду


  
 
Рисунок Б.2 — UML-діаграма компонентів (Component Diagram)


  
 
Рисунок Б.3 — UML-діаграма взаємодії (Interaction Overview Diagram


  
 
Рисунок Б.4.1 — UML-діаграма діяльності (Activity Diagram), частина 1


  
 
Рисунок Б.4.2 — UML-діаграма діяльності (Activity Diagram), частина 2










ДОДАТОК В
Фрагменти програмного коду
Збереження та отримання даних із SQL (Node.js + Express + SQLite)
backend/database.js

1. const sqlite3 = require('sqlite3').verbose();
2. const db = new sqlite3.Database('./soil_monitor.db');

3. db.serialize(() => {
4.   db.run(`
5.     CREATE TABLE IF NOT EXISTS users (
6.       id INTEGER PRIMARY KEY AUTOINCREMENT,
7.       name TEXT NOT NULL,
8.       email TEXT NOT NULL UNIQUE,
9.       password TEXT NOT NULL
10.    )`);
11.
12.  db.run(`
13.    CREATE TABLE IF NOT EXISTS soil_data (
14.      id INTEGER PRIMARY KEY AUTOINCREMENT,
15.      location TEXT,
16.      ph TEXT,
17.      nitrogen TEXT,
18.      potassium TEXT,
19.      phosphorus TEXT,
20.      moisture TEXT,
21.      density TEXT,
22.      culture TEXT,
23.      user_id INTEGER,
24.      FOREIGN KEY(user_id) REFERENCES users(id)
25.    )`);
26. });

27. module.exports = db;

 backend/routes/user.js

1. const express = require('express');
2. const db = require('../database');
3. const router = express.Router();

4. // Реєстрація
5. router.post('/register', (req, res) => {
6.   const { name, email, password } = req.body;
7.   const query = `INSERT INTO users (name, email, password) VALUES (?, ?, ?)`;

8.   db.run(query, [name, email, password], function(err) {
9.     if (err) return res.status(400).json({ error: 'Email вже використовується' });
10.    res.status(201).json({ id: this.lastID });
11.  });
12. });

13. // Отримання користувача
14. router.get('/profile/:email', (req, res) => {
15.   const query = `SELECT * FROM users WHERE email = ?`;
16.   db.get(query, [req.params.email], (err, row) => {
17.     if (err || !row) return res.status(404).json({ error: 'Користувача не знайдено' });
18.     res.json(row);
19.   });
20. });

21. module.exports = router;

 backend/routes/soil.js
1. const express = require('express');
2. const db = require('../database');
3. const router = express.Router();

4. // Збереження ґрунтових даних
5. router.post('/save', (req, res) => {
6.   const {
7.     location, ph, nitrogen, potassium, phosphorus,
8.     moisture, density, culture, user_id
9.   } = req.body;

10.  const query = `
11.    INSERT INTO soil_data (
12.      location, ph, nitrogen, potassium, phosphorus,
13.      moisture, density, culture, user_id
14.    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
15.  `;

16.  db.run(query, [
17.    location, ph, nitrogen, potassium, phosphorus,
18.    moisture, density, culture, user_id
19.  ], function(err) {
20.    if (err) return res.status(500).json({ error: 'Помилка збереження' });
21.    res.status(201).json({ id: this.lastID });
22.  });
23. });

24. // Отримання всіх даних
25. router.get('/all', (req, res) => {
26.   db.all(`SELECT * FROM soil_data`, [], (err, rows) => {
27.     if (err) return res.status(500).json({ error: 'Помилка отримання даних' });
28.     res.json(rows);
29.   });
30. });
31. module.exports = router;




 backend/server.js

1. const express = require('express');
2. const cors = require('cors');
3. const app = express();
4. const PORT = 3001;

5. const userRoutes = require('./routes/user');
6. const soilRoutes = require('./routes/soil');

7. app.use(cors());
8. app.use(express.json());

9. app.use('/api/users', userRoutes);
10. app.use('/api/soil', soilRoutes);

11. app.listen(PORT, () => {
12.   console.log(`✅ Сервер запущено на http://localhost:${PORT}`);
13. });

